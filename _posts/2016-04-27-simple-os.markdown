---
layout: post
title:  "Simple OS"
date:   2016-04-27 15:50:03 -0400
categories: OS
---

First, we need to create a boot sector on our disk.

We can create by using machine codes of our CPU.


e9 fd ff 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa


0xe9, 0xfd, and 0xff are machine instructions defined by the manufacturer of the CPU.
When BIOS is going to reach end of the memory block. It will read 0x55 and 0xaa which is
0xaa55 magic number in small endian. This number will tell BIOS that we deal with boot block.
So BIOS is going to interpret all instruction before magic number and after as a machine code
instructions and not some data. In other words, if you don't have a loop BIOS will just
continue reading. It'll read all of the data on the disk and if it reaches random sequence of bytes
that happen to reformat disk. It will do it.

It is difficult to remember all machine instructions for different CPU's. So assemblers
have been invented. They translate reader friendly instructions into machine code. 




**Instructions in boot_sect.asm**

{% highlight nasm %}
									;
									; A simple boot sector program that loops forever.
									;
loop :								; Define a label , " loop " , that will allow
									; us to jump back to it , forever.

	jmp loop						;Use a simple CPU instruction that jumps
									;to a new memory address to continue execution.
									;In our case , jump to the address of the current
									;instruction.

times 510 -( $ - $$ ) db 0 			; When compiled, our program must fit into 512 bytes,
									; with the last two bytes being the magic number
									; so here, tell our assembly compiler to pad out our
									;program with enough zero bytes (db 0) to bring us to 510th byte

dw 0 xaa55							;last two bytes are magic number so that BIOS knows we
									;are a boot sector
{% endhighlight %}



We can assemble previous code into machine instructions by:


{% highlight shell %}
$nasm boot_sect.asm -f bin -o boot_sect.bin //we compile our boot_sect.asm
$ -f bin: instructs nasm to produce raw machine code
$
$bochs "floppya : 1 _44 = boot_sect.bin , status = inserted" //we instruct bochs emulator to treat compiled code as a floppy disk
$															 //there should nothing be displayed since we have infinite loop
$qemu-system-x86_64 boot_sect.bin //also can be used
{% endhighlight %}



To run and debug NASM programs we can put them into (SASM IDE)[http://dman95.github.io/SASM/english.html]. 